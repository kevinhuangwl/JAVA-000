# 1.（选做）列举常用的并发操作 API 和工具类，简单分析其使用场景和优缺点。
并发工具类按使用场景，可以分为以下几类

## 分工
### Thread
场景：写demo时用  
优点：简单，用完自行销毁  
缺点：耗时，创建效率低

### ThreadPoolExecutor
场景：生产级代码，处理一般任务  
优点：线程复用  
缺点：容易忽略对任务队列与拒绝策略的设置而导致线上问题  

### ScheduledThreadPoolExecutor  
场景：生产级代码，处理定时任务  
优点：自动计时  
缺点：暂时没有想到

## 协作
### Semaphore
场景：限制N个线程进行活动
优点：通过信号量的数目，可以灵活控制不同线程
缺点：暂时没有想到

### CountDownLatch
场景：适合主线程等待多个工作线程的一次性任务
优点：代码更容易理解
缺点：如果要多次循环就要创建多次对象

### CyclicBarrier
场景：适合主线程等待多个工作线程的循环任务
优点：一次创建多次使用
缺点：代码不直观

### FutureTask
场景：适合两个线程间的协作
优点：暂时没有想到
缺点：不支持多任务

### CompletableFuture
场景：适合两个线程间的协作，尤其是多任务间的协作
优点：支持多任务，多种组合方式
缺点：默认使用ForkJoin线程池，不能在任务中有阻塞操作


## 互斥
### synchronize
场景：对资源访问进行互斥限制
优点：低竞争场景，借用偏向锁与轻量级锁，可使程序效率更高
缺点：多线程竞争场景，会升级为重量级锁，导致性能下降；只能支持单条件

### ReentrantLock
场景：对资源访问进行互斥限制
优点：高并发场景下，性能比较稳定；可以支持多条件控制
缺点：暂时没有想到

### ThreadLocal
场景：用于寄存线程独占的对象，使对象不会产生线程安全问题；   
优点：不会产生线程安全问题；  
缺点：容易忘记清理残留对象；由于是隐式传参，代码不容易发现问题

### ConcurrentHashMap

### ConcurrentLinkedList

### ArrayBlockingQueue


# 2.（选做）请思考：什么是并发？什么是高并发？实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的？
 
# 3.（选做）请思考：还有哪些跟并发类似 / 有关的场景和问题，有哪些可以借鉴的解决办法。
